diff --git a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Scope.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Scope.java
index 2482368fad3c..907171a701c7 100644
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Scope.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Scope.java
@@ -272,9 +272,9 @@ public static WriteableScope create(Symbol owner) {
     }
 
     private static class ScopeImpl extends WriteableScope {
-        /** The number of scopes that share this scope's hash table.
+        /** true if this scope's hash table is shared with a nested scope.
          */
-        private int shared;
+        private boolean shared;
 
         /** Next enclosing scope (with whom this scope may share a hashtable)
          */
@@ -339,8 +339,10 @@ public ScopeImpl(Symbol owner) {
          *  of fresh tables.
          */
         public WriteableScope dup(Symbol newOwner) {
+            Assert.check(!shared);
+
             ScopeImpl result = new ScopeImpl(this, newOwner, this.table, this.nelems);
-            shared++;
+            shared = true;
             // System.out.println("====> duping scope " + this.hashCode() + " owned by " + newOwner + " to " + result.hashCode());
             // new Error().printStackTrace(System.out);
             return result;
@@ -351,7 +353,7 @@ public WriteableScope dup(Symbol newOwner) {
          *  the table of its outer scope.
          */
         public WriteableScope dupUnshared(Symbol newOwner) {
-            if (shared > 0) {
+            if (shared) {
                 //The nested Scopes might have already added something to the table, so all items
                 //that don't originate in this Scope or any of its outer Scopes need to be cleared:
                 Set<Scope> acceptScopes = Collections.newSetFromMap(new IdentityHashMap<>());
@@ -383,7 +385,7 @@ public WriteableScope dupUnshared(Symbol newOwner) {
          *  with next.
          */
         public WriteableScope leave() {
-            Assert.check(shared == 0);
+            Assert.check(!shared);
             if (table != next.table) return next;
             while (elems != null) {
                 int hash = getIndex(elems.sym.name);
@@ -392,8 +394,8 @@ public WriteableScope leave() {
                 table[hash] = elems.shadowed;
                 elems = elems.nextSibling;
             }
-            Assert.check(next.shared > 0);
-            next.shared--;
+            Assert.check(next.shared);
+            next.shared = false;
             next.nelems = nelems;
             // System.out.println("====> leaving scope " + this.hashCode() + " owned by " + this.owner + " to " + next.hashCode());
             // new Error().printStackTrace(System.out);
@@ -403,12 +405,12 @@ public WriteableScope leave() {
         /** Double size of hash table.
          */
         private void dble() {
-            Assert.check(shared == 0);
+            Assert.check(!shared);
             Entry[] oldtable = table;
             Entry[] newtable = new Entry[oldtable.length * 2];
             for (ScopeImpl s = this; s != null; s = s.next) {
                 if (s.table == oldtable) {
-                    Assert.check(s == this || s.shared != 0);
+                    Assert.check(s == this || s.shared);
                     s.table = newtable;
                     s.hashMask = newtable.length - 1;
                 }
@@ -429,7 +431,7 @@ private void dble() {
         /** Enter symbol sym in this scope.
          */
         public void enter(Symbol sym) {
-            Assert.check(shared == 0);
+            Assert.check(!shared);
             if (nelems * 3 >= hashMask * 2)
                 dble();
             int hash = getIndex(sym.name);
@@ -449,7 +451,7 @@ public void enter(Symbol sym) {
         /** Remove symbol from this scope.
          */
         public void remove(Symbol sym) {
-            Assert.check(shared == 0);
+            Assert.check(!shared);
             Entry e = lookup(sym.name, candidate -> candidate == sym);
             if (e.scope == null) return;
 
@@ -487,7 +489,7 @@ else while (true) {
         /** Enter symbol sym in this scope if not already there.
          */
         public void enterIfAbsent(Symbol sym) {
-            Assert.check(shared == 0);
+            Assert.check(!shared);
             Entry e = lookup(sym.name);
             while (e.scope == this && e.sym.kind != sym.kind) e = e.next();
             if (e.scope != this) enter(sym);
diff --git a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
index 0ff738e210db..c158f1f66c01 100644
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
@@ -1761,7 +1761,7 @@ private void handleSwitch(JCTree switchTree,
                         JCExpression guard = patternlabel.guard;
                         if (guard != null) {
                             MatchBindings afterPattern = matchBindings;
-                            Env<AttrContext> bodyEnv = bindingEnv(env, matchBindings.bindingsWhenTrue);
+                            Env<AttrContext> bodyEnv = bindingEnv(switchEnv, matchBindings.bindingsWhenTrue);
                             try {
                                 attribExpr(guard, bodyEnv, syms.booleanType);
                             } finally {
